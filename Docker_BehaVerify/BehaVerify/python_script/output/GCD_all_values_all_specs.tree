#{Comments are placed within matching brackets like this. You *CANNOT* nest comments}#
configuration {
    #{We'll ignore this for now}#
}
enumerations {
    #{We'll also ignore this for now}#
}

constants {
    max_val := 100
}

variables {
    #{
	We *do* need a variable though.
	This variable will track the value of our number.
    }#
    variable {
	bl #{type}#
	a #{name}#
	FROZENVAR #{Modeled as}#
	[1, max_val] #{Domain}#
	assign {
	    result{
		(loop, loop_var, [1, max_val] such_that True, loop_var)
		#{pick an option nondeterministically}#
	    }
	}
    }
    variable {
	bl #{type}#
	b #{name}#
	FROZENVAR #{Modeled as}#
	[1, max_val] #{Domain}#
	assign {
	    result{
		(loop, loop_var, [1, max_val] such_that True, loop_var)
		#{pick an option nondeterministically}#
	    }
	}
    }
    variable {
	bl #{type}#
	x #{name}#
	VAR #{Modeled as}#
	[1, max_val] #{Domain}#
	assign {
	    result{
		a
	    }
	}
    }
    variable {
	bl #{type}#
	y #{name}#
	VAR #{Modeled as}#
	[1, max_val] #{Domain}#
	assign {
	    result{
		b
	    }
	}
    }
    
    variable {
	local
	temp
	VAR
	[1, max_val]
	assign {
	    result {
		1
	    }
	}
    }
}

environment_update {
}

checks {
    check {
	no_swap
	arguments {}
	read_variables {x, y}
	condition{ (gte, x, y) }
    }
    check {
	done
	arguments {}
	read_variables {x, y}
	condition { (eq, (mod, x, y), 0) }
    }
}

environment_checks {
}

actions {
    action {
	swap
	arguments {}
	local_variables {temp}
	read_variables {}
	write_variables {x, y}
	initial_values {}
	update {
	    variable_statement{
		temp
		assign{result{x}}
	    }
	    variable_statement{
		x
		assign{result{y}}
	    }
	    variable_statement{
		y
		assign{result{temp}}
	    }
	    return_statement{result{success}}
	}
    }
    action {
	next_value
	arguments {}
	local_variables {}
	read_variables {y}
	write_variables {x}
	initial_values {}
	update {
	    variable_statement{
		x
		assign{result{(max, 1, (mod, x, y))}}
	    }
	    return_statement{result{running}}
	}
    }
}


sub_trees {
}

tree {
    composite {
	gcd
	sequence
	children {
	    composite {
		swap_sel
		selector
		children {
		    no_swap {}
		    swap {}
		}
	    }
	    composite {
		iterate_sel
		selector
		children {
		    done {}
		    next_value {}
		}
	    }
	}
    }	
}

tick_prerequisite {
    True
}

specifications {
    LTLSPEC {
	(finally,
	    (globally,
		(and,
		    (success, gcd),
		    (eq, (mod, a, y), 0),
		    (eq, (mod, b, y), 0),
		    (loop, loop_var, [1, max_val] such_that True,
			(or,
			    (lte, loop_var, y),
			    (neq, (mod, a, loop_var), 0),
			    (neq, (mod, b, loop_var), 0)
			)
		    )
		)
	    )
	)
    }
}